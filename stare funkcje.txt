double count2OptPathCost(vector<int> path, double **A) {
    double cost = 0;
    for (int i = 1; i < path.size(); i++) {
        cost += A[path[i - 1] - 1][path[i] - 1];
    }
    cost += A[path[0] - 1][path[path.size() - 1] - 1];
    return cost;
}

void twoOptSwap(vector<int> &newRoute, vector<int> currentRoute, int i, int k) {
    for (int j = 0; j < i; j++) newRoute.push_back(currentRoute[j]);
    for (int j = k; j >= i; j--) newRoute.push_back(currentRoute[j]);
    for (int j = k + 1; j < currentRoute.size(); j++) newRoute.push_back(currentRoute[j]);
}

void twoOptLocalSearch(vector<int> &path, double &cost, double **A) {
    bool improvementMade = false;
    do {
        improvementMade = false;
        for (int i = 0; i < path.size(); i++) {
            for (int k = i + 1; k < path.size(); k++) {
                vector<int> newPath;
                twoOptSwap(newPath, path, i, k);
                double newCost = count2OptPathCost(newPath, A);
                if (newCost < cost) {
                    path = newPath;
                    //show2OptPath(path);
                    cost = newCost;
                    improvementMade = true;
                }
            }
        }
    } while (improvementMade);
    path.push_back(path[0]);
}

double costOfPath(double **A, int *path, int n) {
    double cost = 0;
    for (int i = 0; i < n; i++) cost += A[path[i] - 1][path[i + 1] - 1];
    cost+=A[path[n-1]][path[0]];
    return cost;
}

void getNeighbours(double **A, int *path, int n, double **neighbourCost, double currentCost, double &bestNeighbourCost,
              int &bestNodeRowIndex, int &bestNodeColumnIndex) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            //cout << "tutaj " << i << " " << j << endl;
            if (i == 0) {
                if (j - i == 1) {
                    neighbourCost[path[i] - 1][path[j] - 1] =
                            currentCost - A[0][path[i] - 1] + A[0][path[j] - 1] - A[path[j] - 1][path[j + 1] - 1] +
                            A[path[i] - 1][path[j + 1] - 1];
                    bestNeighbourCost = neighbourCost[path[i] - 1][path[j] - 1];
                    bestNodeRowIndex = i;
                    bestNodeColumnIndex = j;
                } else {
                    neighbourCost[path[i] - 1][path[j] - 1] =
                            currentCost - A[0][path[i] - 1] + A[0][path[j] - 1] - A[path[j] - 1][path[j + 1] - 1] +
                            A[path[i] - 1][path[j + 1] - 1] - A[path[i] - 1][path[i + 1] - 1] +
                            A[path[j] - 1][path[i + 1] - 1] -
                            A[path[j - 1] - 1][path[j] - 1] + A[path[j - 1] - 1][path[i] - 1];

                }
            } else {
                if (j - i == 1) {
                    neighbourCost[path[i] - 1][path[j] - 1] =
                            currentCost - A[path[i - 1] - 1][path[i] - 1] + A[path[i - 1] - 1][path[j] - 1] -
                            A[path[j] - 1][path[j + 1] - 1] +
                            A[path[i] - 1][path[j + 1] - 1];
                } else {
                    neighbourCost[path[i] - 1][path[j] - 1] =
                            currentCost - A[path[i - 1] - 1][path[i] - 1] + A[path[i - 1] - 1][path[j] - 1] -
                            A[path[j] - 1][path[j + 1] - 1] +
                            A[path[i] - 1][path[j + 1] - 1] - A[path[i] - 1][path[i + 1] - 1] +
                            A[path[j] - 1][path[i + 1] - 1] -
                            A[path[j - 1] - 1][path[j] - 1] + A[path[j - 1] - 1][path[i] - 1];
                };
            }
            if (neighbourCost[path[i] - 1][path[j] - 1] < bestNeighbourCost) {
                bestNeighbourCost = neighbourCost[path[i] - 1][path[j] - 1];
                bestNodeRowIndex = i;
                bestNodeColumnIndex = j;
            }
        }
    }
}
template<typename T>
void showTable(T **Table,int n){
    for(int i = 0;i<n;i++){
        for(int j=0;j<n;j++){
            cout<<Table[i][j]<<" ";
        }
        cout<<endl;
    }
    cout<<endl;
}


 //double twoOptCost = cost;
//    for (int i = 0; i < n; i++)pathFor2Opt.push_back(path[i]);
//    twoOptLocalSearch(pathFor2Opt, twoOptCost, A);
//    cout << endl << "2opt" << endl;
//    cout << "cost: " << twoOptCost << endl;
//    show2OptPath(pathFor2Opt);

void show2OptPath(vector<int> path) {
    cout << "path: ";
    for (int i = 0; i < path.size(); i++)cout << path[i] << ' ';
    cout << endl;
}

vector<int> pathFor2Opt;